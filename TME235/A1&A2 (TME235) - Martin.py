#%%
%matplotlib widget
from funcs_n_imports import *
from quadmesh import *

#%%
# Given problem information

L1 = 3
L2 = 0.3

E_num = 220 * 10**9
b_num = 0.05
h_num = b_num
I_num= b_num * h_num**3 / 12 #moment of inertia
rho_num = 7800 #density
g_num = 9.81
m_num = 130
P_num = -m_num * g_num
poisson_num = 0.3

Ks_num = 5/6
A_num = b_num * h_num
G_num = E_num / (2 * (1 + poisson_num)) 


#%% ###################### Method 1: dsolve ##############################
# EULER-BERNOULLI
##################################################
new_prob(1)
print("\nCantilever Beam - Point Load at Free End")

## Define symbolic variables
P, x, L, E, I = symbols('P x L E I', real=True)
w = Function('w')(x) # w is a function of x

## Define the load (0 for point load at end)
q = 0

## Define the differential equation
diffeq = Eq(E * I * w.diff(x, 4), q)
print('\ndifferential equation:')
display(diffeq)

## Solve the differential equation for w(x)
w_general = dsolve(diffeq, w).rhs
print('\ngeneral equation for w:')
display(w_general)

## bending moment
M = -E * I * w_general.diff(x, 2)
print('\nmomentum equation:')
display(M)

## shear 
V = - E * I * w_general.diff(x,3)
print('\nshear equation:')
display(V)

## Define boundary conditions, rewrite so that element = 0 
boundary_conditions = [ w_general.subs(x, 0),               # w(0) = 0
                        w_general.diff(x).subs(x, 0),       # w'(0) = 0
                        V.subs(x, L) + P,                   # V(L) = P
                        M.subs(x, L)]                       # M(L) = 0
print('\nboundary conditions:')
display(boundary_conditions)

## solve for the integration constants
integration_constants = solve(boundary_conditions, 'C1, C2, C3, C4', real=True)  # C1-C4 are generated by the `dsolve` call
print('\nintegration constants:')
display(integration_constants)

## apply the constants to get the final deflection expression
solution = simplify(w_general.subs(integration_constants)) 

print(f"\nDeflection: w(x):")
display(solution)
print(f"\nMax deflection at x=L: w_max = {simplify(solution.subs(x, L))}")

## moment and shear with solution
M_solution = simplify(M.subs(integration_constants))
V_solution = simplify(V.subs(integration_constants))
# print(V_solution.evalf(subs={P:5}))

print(f"\nMoment: M(x):")
display(M_solution)

print(f"\nShear: V(x):")
display(V_solution)



# %%
##################################################
# TIMOSHENKO
##################################################
new_prob(2)

#############
# Poiint load

x, q0, E, I, Ks, G, A, L, P = symbols('x q0 E I Ks G A L P', real=True)

f_phi = Function('phi') # phi is a function of x

## Define the differential equation in terms of phi
diffeq_phi = Eq(E*I*f_phi(x).diff(x, 3), 0)

## Solve the differential equation for phi(x) (eq. 3.35 LN)
phi = dsolve(diffeq_phi, f_phi(x)).rhs

## Solve the differential equation for w(x) (eq. 3.36 LN)
w = Function('w') # w is a function of x
diffeq_w = Eq(w(x).diff(x), -E*I/(G*Ks*A)*phi.diff(x,2) + phi)
w        = dsolve(diffeq_w, w(x)).rhs

## Define boundary conditions
M = -E*I*phi.diff(x)
bc_eqs = [
    Eq(w.subs(x, 0), 0),                # w(0) = 0
    Eq(diff(w, x).subs(x, 0), 0),       # w'(0) = 0
    Eq(diff(w, x, 2).subs(x, L), 0),    # w''(L) = 0
    Eq(diff(w, x, 3).subs(x, L), -P/(E*I))  # w'''(L) = -P/(EI)
]

## Solve for the integration constants
integration_constants = solve(bc_eqs, 'C1, C2, C3, C4', real=True)

## Substitute the integration constants into the solution
solution1 = w.subs(integration_constants)
display(solution1)

##################
# Distributed load

## Define symbolic variables
x, q0, E, I, Ks, G, A, L = symbols('x q0 E I Ks G A L', real=True)

f_phi = Function('phi') # phi is a function of x

## Define the differential equation in terms of phi
diffeq_phi = Eq(E*I*f_phi(x).diff(x, 3), q0)

## Solve the differential equation for phi(x) (eq. 3.35 LN)
phi = dsolve(diffeq_phi, f_phi(x)).rhs

## Solve the differential equation for w(x) (eq. 3.36 LN)
w = Function('w') # w is a function of x
diffeq_w = Eq(w(x).diff(x), -E*I/(G*Ks*A)*phi.diff(x,2) + phi)
w        = dsolve(diffeq_w, w(x)).rhs

## Define boundary conditions
M = -E*I*phi.diff(x)
boundary_conditions1 = [ w.subs(x, 0), 0,               #w(0) = 0
                        w.diff(x).subs(x, 0),           #w'(0) = 0
                        M.subs(x, L), 0,                #w''(L) = 0
                        w.diff(x,3).subs(x, L), 0]      #w'''(L) = 0

## Solve for the integration constants
integration_constants = solve(boundary_conditions1, 'C1, C2, C3, C4', real=True)

## Substitute the integration constants into the solution
solution2 = w.subs(integration_constants)
display(solution2)

solution_total = solution1 + solution2
display(simplify(solution_total))

w_func = lambdify((x, L, q0, P, E, I, Ks, A, G), solution_total, 'numpy')

## Plugging in values for the length of the beam and plotting

L = L1
q0 = -((m_num * g_num)/L)    

x_vals = np.linspace(0, L, 200)
w_vals = w_func(x_vals, L, q0, P_num, E_num, I_num, A_num, G_num, Ks_num)

plt.figure(figsize=(10,6))
plt.plot(x_vals, w_vals*1e3, 'b-', linewidth=2)
plt.title('Beam Deflection under Combined Loading at L=3', fontsize=16)
plt.xlabel('Position along beam (m)', fontsize=14)
plt.ylabel('Deflection (mm)', fontsize=14)
plt.grid(True)
plt.axhline(0, color='black', linewidth=0.8, linestyle='--')
plt.ylim(bottom=min(w_vals)*1e3*1.1)
plt.xlim(0, L)
plt.show()

L=L2
q0 = -((m_num * g_num)/L2)

x_vals = np.linspace(0, L, 200)
w_vals = w_func(x_vals, L, q0, P_num, E_num, I_num, A_num, G_num, Ks_num)

plt.figure(figsize=(10,6))
plt.plot(x_vals, w_vals*1e3, 'b-', linewidth=2)
plt.title('Beam Deflection under Combined Loading at L=0.3', fontsize=16)
plt.xlabel('Position along beam (m)', fontsize=14)
plt.ylabel('Deflection (mm)', fontsize=14)
plt.grid(True)
plt.axhline(0, color='black', linewidth=0.8, linestyle='--')
plt.ylim(bottom=min(w_vals)*1e3*1.1)
plt.xlim(0, L)
plt.show()

#%%