#%% import necessary packages
import numpy as np
from sympy import *
import matplotlib.pyplot as plt
from matplotlib import rcParams # for changing default values
import matplotlib.ticker as ticker

"""
    Problem 9: Solve the deflection of a beam using Euler-Bernoulli beam theory

    Governing differential equation: E*I*d^4w/dx^4 = q(x)
    Unknown: w(x) - deflection of the beam
    BCs: w(0)=0, w'(0)=0, w(L)=0, M(L)=0
"""
#%% ###################### Method 1: dsolve ##############################
## Define symbolic variables
q0, x, L, E, I = symbols('q0 x L E I', real=True)
w = Function('w')(x) # w is a function of x

## Define the differential equation
diffeq = Eq(E*I*w.diff(x, 4), q0*x/L)

## Solve the differential equation for w(x)
w = dsolve(diffeq, w).rhs

## bending moment
M = -E*I*w.diff(x, 2)

## Define boundary conditions 
boundary_conditions = [ w.subs(x, 0),            # w(0) = 0
                        w.diff(x).subs(x, 0),    # w'(0) = 0
                        w.subs(x, L),            # w(L) = 0
                        M.subs(x, L)]            # M(L) = 0

## Solve for the integration constants
integration_constants = solve(boundary_conditions, 'C1, C2, C3, C4', real=True)  # C1-C4 are generated by the `dsolve` call

## Apply the constants to get the final deflection expression
solution = w.subs(integration_constants)
solution   
#%%######################## Method 2: Integrate by hand ##############################
## Define symbolic variables and integration constants
q0, x, L, E, I = symbols('q0 x L E I', real=true)
C1, C2, C3, C4 = symbols('C1 C2 C3 C4', real=true)

## deflection field obtained by integrating the governing equation four times
## S("1/2") generates a sympy rational number
w = S("1/120") * q0 / (E*I*L) * x**5 + S("1/6") * C1 * x**3 + S("1/2") * C2 * x**2 + C3 * x + C4

## bending moment
M = -E*I*w.diff(x, 2)

## Define boundary conditions to solve for integration constants
boundary_conditions = [ w.subs(x, 0),
                        w.diff(x).subs(x, 0),
                        w.subs(x, L),
                        M.subs(x, L)]

## Solve for the integration constants
integration_constants = solve(boundary_conditions, (C1, C2, C3, C4))  # C1-C4 are defined as symbols already

## Apply the constants to get the final deflection expression
solution = w.subs(integration_constants)  
solution                            
# %% ######################## Numerical example ##############################
Emod = 200e3;     #MPa
Lmod = 1e3;       #mm
h    = 50;        #mm
b    = 50;        #mm
Imod = b*h**3/12; #moment of inertia
qmod = 0.5;       #N/mm

# substitute numerical values
w_EB_sol    =simplify(solution.subs({E:Emod, I:Imod, L:Lmod, q0:qmod}))

# make numeric callables of w(x)
lambda_w_EB = lambdify(x, w_EB_sol, 'numpy')

L_vals = np.linspace(0, Lmod, 100)

# Plot w(x)
plt.rcParams["font.family"] = "Times New Roman"
plt.rcParams["font.size"] = 18
plt.rcParams['mathtext.fontset'] = 'cm'
size_in_inch = (22.0/2.54, 14/2.54)  # Convert cm to inches

fig, ax = plt.subplots(nrows=1, ncols=1, figsize=size_in_inch)  
plt.plot(lambda_w_EB(L_vals),  linewidth=1, color='b')
plt.xlabel(r'$x$ [mm]')
plt.ylabel(r'$w(x)$ [mm]')
plt.tick_params(which='both', direction='in')
# scientific notation for y-axis
formatter = ticker.ScalarFormatter(useMathText=True)
formatter.set_powerlimits((0, 0))  
ax.yaxis.set_major_formatter(formatter)
plt.savefig('Problem9_EB_deflection.png')
plt.show()
# %%
